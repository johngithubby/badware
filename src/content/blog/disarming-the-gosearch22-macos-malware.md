---
title: 'Disarming the GoSearch22 macOS Malware'
description: 'Why GoSearch22 exits with -1 under LLDB and how to re-sign it so you can actually debug it.'
pubDate: 'Sep 30 2025'
heroImage: '../../assets/blog-placeholder-5.jpg'
---

This malware employs several anti-debug techniques, as laid out in the last chapter of the Blue Fox book. If you just launch it straight under LLDB (for example: `lldb GoSearch22.app`), the book claims it will immediately exit with code `45` because it calls `ptrace` (or `syscall` wrapper) using the `PT_DENY_ATTACH` flag.

When I tried it myself, that's not what actually happened: it exited with `-1`.

Why?

## Observed behavior

macOS Console (search for `debugserver`) logged:

```
[LaunchAttach] (3983) about to task_for_pid(3982)
error: [LaunchAttach] MachTask: :TaskPortForProcessID task_for_pid(3982) failed: ::task_for_pid ( target_tport = 0x8203, pid = 3982, &task) => err = 0x90800885 ((os/kern) failure)
```

That's macOS itself refusing a debugger attach *before* LLDB can properly establish the debugging session.

## Likely root causes

This can happen because of one (or both) of:

1. Code signing + hardened runtime: If the binary is signed with the hardened runtime and does **not** have the `com.apple.security.get-task-allow` entitlement, `task_for_pid()` fails for LLDB.
2. Very early `PT_DENY_ATTACH`: If the process invokes `ptrace(PT_DENY_ATTACH, ...)` extremely early (e.g. inside a constructor / `+load` / init section) the kernel denies the debugger right away.

## Verifying the signature & entitlements

Command used:

```
codesign -dvvvv --entitlements :- GoSearch22.app
```

Relevant output (trimmed):

```
Identifier=com.GoSearch22
Format=app bundle with Mach-O universal (x86_64 arm64)
CodeDirectory v=20500 size=4122 flags=0x10000(runtime)
Authority=Developer ID Application: hongsheng yan (K69G52FWT9)
TeamIdentifier=K69G52FWT9
Runtime Version=11.0.0
```

The important bit: `flags=0x10000 (runtime)` indicates the hardened runtime is enabled. There is no `get-task-allow` entitlement present. Under these conditions, macOS blocks debugger attachment via `task_for_pid`.

Therefore LLDB never reaches a state where it would report the `45` exit caused by a user‑space `PT_DENY_ATTACH`; instead you just see a failure to attach and the process terminates showing `-1` on your side.

## Making it debuggable

Strip the existing Developer ID signature (and thus the hardened runtime), then ad‑hoc sign it so macOS will still run it but allow debugging:

```
sudo codesign --remove-signature GoSearch22.app
sudo codesign -s - --force --deep GoSearch22.app
```

Explanation:

- `--remove-signature` removes the original Developer ID signature + hardened runtime restrictions.
- `-s -` applies an ad-hoc signature (a placeholder) that macOS accepts for local execution and permits debugging.
- `--deep` ensures nested Mach-O binaries inside the bundle are also (re)signed.

## Launching under LLDB after re-signing

Now you can do:

```
lldb GoSearch22.app
(lldb) settings set target.disable-aslr true
(lldb) process launch --stop-at-entry
```

At this point the debugger should successfully attach at the entry point, but if allowed to run, it will exit with code 45 at last; a sign that the malware knows it is being debugged. How does it know?
If one sets a berakpoint on the entry of ptrace itself:

```
br se -n ptrace
Breakpoint 3: where = Libsystem_kernel.dylib ptrace, address = 0x000000018d5d2a34
```

and run again, the breakpoint is not hit, and the process still exits with a 45 code. So something else is used. The book says it also uses a `sysctl` to detect active debugging, so let's break there:

```
br se -n sysctl
Breakpoint 4: where = libsystem_c.dylib sysctl, address = 0x000000018d49e864
```

and now when run again, this breakpoint is hit:

```
(lldb) r
Process 7060 launched: GoSearch22_arm64' (arm64)
Process 7060 stopped
* thread #1, queue = 'com. apple.main-thread', stop reason = breakpoint 4.1
frame #0: 0x000000018d49e864 libsystem_c-dylib sysctl
libsystem_c. dylib' sysctl:
→   0x18d49e864 <+0>:   pacibsp
        0x18d49e868 <+4>:   stp x29, x30, [sp, #-0x10]!
        0x18d49e86c <+8>:   mov x29, sp
        0x18d49e870 <+12>:  ldr  w8, [x0]
```

Since we're already inside `sysctl`, let's verify if it was called with params for determining whether the process is debugged. The first param `sysctl` is called with is in x0, and it has to be the address of an array that contains four integers. Display the with:

```
(lldb) memory read -f d -s4 -c 4 $x0
```
Meaning, read from the memory address that `x0` contains, and display in decimal format (`-f d`) a count of 4 (`-c 4) groups of 4 bytes (`-s 4`), that is 4 integers, each of 4 * 8 bits. This yields: 

```
0x16fdf7bd0: 1
0x16fdf7bd4: 14
0x16fdf7bd8: 1
0x16fdf7bdc: 7060
```
This is the 4 integer array, and 1, 14 and 1 correspond to named constants `CTL_KERN`, `KERN_PROC` and `KERN_PROC_PID` (the last one 7060, is the PID). These are the values you call `sysctl` to find out the if the process is being debugged, and `sysctl`. 

What's needed now is to look for the jump to the internal `__sysctl`, the code that actually does the lifting, and skip that jump. Eye grepping yields this line:

```
0x18d49e8d8 bl 0x18d5133b0 ; symbol for __sysctl
0x18d49e8dc ldp x29, x30, [sp], #0x10
0x18d49e8e0 retab
```

So now run until that BL, and skip it by:

```
(lldb) reg write $pc 0x18d49e8dc
```

This makes the program counter point to the instruction right after the jump (`bl`), as if one jumped like `b 0x18d49e8dc`. 

See where we're at:

```
(lldb) dis -s $pc -c 2
libsystem_c.dylib sysctl:
→   0x18d49e8dc <+120>: ldp x29, x30, [sp], #0x10
        0x18d49e8e0 <+124>: retab
```
Confirmed that the next instruction is the `ldp` one now, skipped `bl`.
These last two instructions are the epilogue of `sysctl`, so before wrapping up let's make the process think sysctl succeeded (sysctl returns int in w0): 

`(lldb) register write w0 0`

Useful commands:

```
dis -n sysctl (will show the assembly code of sysctl)
dis -a 0x18d49e8d8 (will show the assembly code found at address 0x18d49e8d8)
thread step-inst-over (steps over one instruction)
```